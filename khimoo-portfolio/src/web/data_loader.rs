use serde::{Deserialize, Serialize};
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::JsFuture;
use web_sys::{Request, RequestInit, RequestMode, Response};
use yew::prelude::*;
use std::collections::HashMap;

use crate::config::{get_config, AppConfig};
use crate::core::articles::metadata::ArticleMetadata;
use crate::core::articles::links::ExtractedLink;
use crate::web::types::data_types::NodeRegistry;
use crate::web::types::node_types::{NodeId, NodeContent, NodeType, ConnectionLine, ConnectionLineType, AUTHOR_NODE_ID};
use crate::web::types::physics_types::Position;

/// Articles data structure matching CLI output
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ArticlesData {
    pub articles: Vec<ProcessedArticle>,
    pub generated_at: String,
    pub total_count: usize,
    pub home_articles: Vec<String>,
}

/// Processed article data structure matching CLI output
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ProcessedArticle {
    pub slug: String,
    pub title: String,
    pub metadata: ArticleMetadata,
    pub file_path: String,
    pub outbound_links: Vec<ExtractedLink>,
    pub inbound_links: Vec<ExtractedLink>,
    pub processed_at: String,
}

/// Lightweight article data for list display and node graph construction
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct LightweightArticle {
    pub slug: String,
    pub title: String,
    pub metadata: ArticleMetadata,
    pub inbound_links: Vec<String>, // Pre-calculated for performance optimization
}

impl From<ProcessedArticle> for LightweightArticle {
    fn from(article: ProcessedArticle) -> Self {
        Self {
            slug: article.slug,
            title: article.title,
            metadata: article.metadata,
            inbound_links: article.inbound_links
                .into_iter()
                .map(|link| link.target_slug)
                .collect(),
        }
    }
}

/// Error types for data loading
#[derive(Debug, Clone, PartialEq)]
pub enum DataLoadError {
    NetworkError(String),
    ParseError(String),
    NotFound(String),
    NodeGraphError(String),
}

impl std::fmt::Display for DataLoadError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DataLoadError::NetworkError(msg) => write!(f, "Network error: {}", msg),
            DataLoadError::ParseError(msg) => write!(f, "Parse error: {}", msg),
            DataLoadError::NotFound(msg) => write!(f, "Not found: {}", msg),
            DataLoadError::NodeGraphError(msg) => write!(f, "Node graph error: {}", msg),
        }
    }
}

impl std::error::Error for DataLoadError {}

/// DataLoader provides interface between core modules and web components
/// Handles loading ArticlesData and converting to web-specific data structures
#[derive(Debug, Clone)]
pub struct DataLoader {
    config: &'static AppConfig,
}

impl DataLoader {
    /// Create a new DataLoader instance
    pub fn new() -> Self {
        Self { 
            config: get_config(),
        }
    }

    /// Load articles data from JSON file (generated by CLI)
    /// This is the primary interface to core module data
    pub async fn load_articles(&self) -> Result<ArticlesData, DataLoadError> {
        let url = self.config.data_url("articles.json");

        web_sys::console::log_1(&format!("DataLoader: Loading articles from: {}", url).into());

        match self.fetch_json::<ArticlesData>(&url).await {
            Ok(data) => {
                web_sys::console::log_1(&format!("DataLoader: Successfully loaded {} articles", data.articles.len()).into());
                Ok(data)
            },
            Err(e) => {
                web_sys::console::warn_1(&format!("Failed to load articles data: {}", e).into());
                // Fallback to empty data structure
                Ok(ArticlesData {
                    articles: Vec::new(),
                    generated_at: "1970-01-01T00:00:00Z".to_string(),
                    total_count: 0,
                    home_articles: Vec::new(),
                })
            }
        }
    }

    /// Convert ArticlesData to LightweightArticle for performance optimization
    /// Requirements: 3.2, 3.3 - Data flow optimization
    pub async fn load_lightweight_articles(&self) -> Result<Vec<LightweightArticle>, DataLoadError> {
        let articles_data = self.load_articles().await?;
        let lightweight_articles: Vec<LightweightArticle> = articles_data.articles
            .into_iter()
            .map(LightweightArticle::from)
            .collect();
        
        web_sys::console::log_1(&format!("DataLoader: Converted to {} lightweight articles", lightweight_articles.len()).into());
        Ok(lightweight_articles)
    }

    /// Build NodeRegistry for node graph visualization
    /// Requirements: 3.2, 3.3 - Node graph data construction
    pub async fn build_node_registry(&self) -> Result<NodeRegistry, DataLoadError> {
        let articles_data = self.load_articles().await?;
        let mut registry = NodeRegistry::new();

        web_sys::console::log_1(&"DataLoader: Building node registry from articles data".into());

        // Add author node first
        self.add_author_node(&mut registry)?;

        // Add article nodes
        let mut node_id_counter = 1u32; // Start after author node (0)
        let mut slug_to_node_id: HashMap<String, NodeId> = HashMap::new();

        // First pass: create nodes for all articles
        for article in &articles_data.articles {
            let node_id = NodeId(node_id_counter);
            node_id_counter += 1;

            // Calculate position based on importance and category
            let position = self.calculate_node_position(&article.metadata, node_id);
            
            // Create node content
            let content = NodeContent::Article {
                title: article.title.clone(),
                slug: article.slug.clone(),
            };

            // Add node to registry
            registry.add_node(node_id, position, 30, content);

            // Set category and importance
            if let Some(category) = &article.metadata.category {
                registry.set_node_category(node_id, category.clone());
            }
            registry.set_node_importance(node_id, article.metadata.importance);

            // Calculate inbound count for dynamic sizing
            let inbound_count = article.inbound_links.len();
            registry.set_node_inbound_count(node_id, inbound_count);

            // Update radius based on importance and inbound links
            let dynamic_radius = registry.calculate_dynamic_radius(node_id, Some(article.metadata.importance), inbound_count);
            registry.update_node_radius(node_id, dynamic_radius);

            slug_to_node_id.insert(article.slug.clone(), node_id);
        }

        // Second pass: create connections between nodes
        for article in &articles_data.articles {
            if let Some(&from_node_id) = slug_to_node_id.get(&article.slug) {
                // Add connections to outbound links
                for link in &article.outbound_links {
                    if let Some(&to_node_id) = slug_to_node_id.get(&link.target_slug) {
                        registry.add_edge(from_node_id, to_node_id);
                        
                        // Add connection line with appropriate type and strength
                        let connection_type = match link.link_type {
                            crate::core::articles::links::LinkType::WikiLink => ConnectionLineType::Strong,
                            crate::core::articles::links::LinkType::MarkdownLink => ConnectionLineType::Medium,
                            crate::core::articles::links::LinkType::ExternalLink => ConnectionLineType::Weak,
                        };
                        
                        let strength = match connection_type {
                            ConnectionLineType::Strong => 1.0,
                            ConnectionLineType::Medium => 0.7,
                            ConnectionLineType::Weak => 0.4,
                            _ => 0.5,
                        };

                        registry.add_connection_line(from_node_id, to_node_id, connection_type, strength);
                    }
                }

                // Add connection from author to home display articles
                if article.metadata.home_display {
                    registry.add_edge(AUTHOR_NODE_ID, from_node_id);
                    registry.add_connection_line(AUTHOR_NODE_ID, from_node_id, ConnectionLineType::Medium, 0.8);
                }
            }
        }

        web_sys::console::log_1(&format!("DataLoader: Built node registry with {} nodes and {} connections", 
            registry.positions.len(), 
            registry.connection_lines.len()
        ).into());

        Ok(registry)
    }

    /// Load article by slug (metadata only, content loaded separately)
    pub async fn load_article_by_slug(&self, slug: &str) -> Result<ProcessedArticle, DataLoadError> {
        web_sys::console::log_1(&format!("DataLoader: Looking for article with slug: {}", slug).into());

        let articles_data = self.load_articles().await?;

        let found_article = articles_data.articles
            .into_iter()
            .find(|article| article.slug == slug);

        match found_article {
            Some(article) => {
                web_sys::console::log_1(&format!("DataLoader: Found article: {}", article.title).into());
                Ok(article)
            }
            None => {
                web_sys::console::log_1(&format!("DataLoader: Article not found: {}", slug).into());
                Err(DataLoadError::NotFound(format!("Article not found: {}", slug)))
            }
        }
    }

    /// Load full article content from file path
    pub async fn load_article_content(&self, file_path: &str) -> Result<String, DataLoadError> {
        let url = self.config.article_url(file_path);
        web_sys::console::log_1(&format!("DataLoader: Loading article content from: {}", url).into());

        let opts = RequestInit::new();
        opts.set_method("GET");
        opts.set_mode(RequestMode::Cors);

        let request = Request::new_with_str_and_init(&url, &opts)
            .map_err(|e| DataLoadError::NetworkError(format!("Failed to create request: {:?}", e)))?;

        let window = web_sys::window()
            .ok_or_else(|| DataLoadError::NetworkError("No window object".to_string()))?;

        let resp_value = JsFuture::from(window.fetch_with_request(&request))
            .await
            .map_err(|e| DataLoadError::NetworkError(format!("Fetch failed: {:?}", e)))?;

        let resp: Response = resp_value
            .dyn_into()
            .map_err(|e| DataLoadError::NetworkError(format!("Invalid response: {:?}", e)))?;

        if !resp.ok() {
            return Err(DataLoadError::NotFound(format!(
                "HTTP {}: {}",
                resp.status(),
                resp.status_text()
            )));
        }

        let text = JsFuture::from(resp.text().map_err(|e| {
            DataLoadError::ParseError(format!("Failed to get text: {:?}", e))
        })?)
        .await
        .map_err(|e| DataLoadError::ParseError(format!("Failed to parse text: {:?}", e)))?;

        let content = text.as_string()
            .ok_or_else(|| DataLoadError::ParseError("Response is not a string".to_string()))?;

        Ok(content)
    }

    /// Load article content without front matter metadata (content only)
    pub async fn load_article_content_only(&self, file_path: &str) -> Result<String, DataLoadError> {
        let full_content = self.load_article_content(file_path).await?;
        
        // Parse and extract only the markdown content (without metadata)
        let content_only = self.parse_content_only(&full_content);
        
        web_sys::console::log_1(&"DataLoader: Successfully separated content from metadata".into());
        Ok(content_only)
    }

    /// Generic JSON fetching method
    async fn fetch_json<T>(&self, url: &str) -> Result<T, DataLoadError>
    where
        T: for<'de> Deserialize<'de>,
    {
        let opts = RequestInit::new();
        opts.set_method("GET");
        opts.set_mode(RequestMode::Cors);

        let request = Request::new_with_str_and_init(url, &opts)
            .map_err(|e| DataLoadError::NetworkError(format!("Failed to create request: {:?}", e)))?;

        let window = web_sys::window()
            .ok_or_else(|| DataLoadError::NetworkError("No window object".to_string()))?;

        let resp_value = JsFuture::from(window.fetch_with_request(&request))
            .await
            .map_err(|e| DataLoadError::NetworkError(format!("Fetch failed: {:?}", e)))?;

        let resp: Response = resp_value
            .dyn_into()
            .map_err(|e| DataLoadError::NetworkError(format!("Invalid response: {:?}", e)))?;

        if !resp.ok() {
            return Err(DataLoadError::NotFound(format!(
                "HTTP {}: {}",
                resp.status(),
                resp.status_text()
            )));
        }

        let json = JsFuture::from(resp.json().map_err(|e| {
            DataLoadError::ParseError(format!("Failed to get JSON: {:?}", e))
        })?)
        .await
        .map_err(|e| DataLoadError::ParseError(format!("Failed to parse JSON: {:?}", e)))?;

        let data: T = serde_wasm_bindgen::from_value(json)
            .map_err(|e| DataLoadError::ParseError(format!("Failed to deserialize: {:?}", e)))?;

        Ok(data)
    }

    /// Add author node to the registry
    fn add_author_node(&self, registry: &mut NodeRegistry) -> Result<(), DataLoadError> {
        let author_position = Position { x: 0.0, y: 0.0 }; // Center position
        
        registry.add_author_node(
            author_position,
            "Khimoo".to_string(),
            "/assets/img/author_img_small.webp".to_string(),
            Some("Software Developer & Content Creator".to_string())
        );

        Ok(())
    }

    /// Calculate node position based on metadata
    fn calculate_node_position(&self, metadata: &ArticleMetadata, node_id: NodeId) -> Position {
        // Simple circular layout based on node ID and importance
        let angle = (node_id.0 as f32 * 2.0 * std::f32::consts::PI) / 10.0; // Distribute around circle
        let radius = match metadata.importance {
            5 => 150.0, // High importance closer to center
            4 => 200.0,
            3 => 250.0,
            2 => 300.0,
            1 => 350.0,
            _ => 300.0,
        };

        Position {
            x: radius * angle.cos(),
            y: radius * angle.sin(),
        }
    }

    /// Extract summary from article metadata
    fn extract_summary_from_metadata(&self, metadata: &ArticleMetadata) -> Option<String> {
        // For now, use title as summary. In future, could extract from content
        Some(format!("Category: {:?}, Importance: {}", 
            metadata.category.as_deref().unwrap_or("General"), 
            metadata.importance
        ))
    }

    /// Parse content only (remove front matter)
    fn parse_content_only(&self, content: &str) -> String {
        let content = content.trim();
        
        // Check if content starts with front matter delimiter
        if content.starts_with("---") {
            let lines: Vec<&str> = content.lines().collect();
            
            // Find the closing delimiter
            let mut end_index = None;
            for (i, line) in lines.iter().enumerate().skip(1) {
                if line.trim() == "---" {
                    end_index = Some(i);
                    break;
                }
            }
            
            if let Some(end_idx) = end_index {
                // Return content after the closing delimiter
                let remaining_lines = &lines[end_idx + 1..];
                return remaining_lines.join("\n").trim_start().to_string();
            }
        }
        
        // No front matter found, return original content
        content.to_string()
    }
}

impl Default for DataLoader {
    fn default() -> Self {
        Self::new()
    }
}

/// Hook for using DataLoader in Yew components
#[hook]
pub fn use_data_loader() -> UseStateHandle<Option<DataLoader>> {
    use_state(|| Some(DataLoader::new()))
}

/// Hook for loading articles data
#[hook]
pub fn use_articles_data() -> (UseStateHandle<Option<ArticlesData>>, UseStateHandle<bool>, UseStateHandle<Option<DataLoadError>>) {
    let data = use_state(|| None);
    let loading = use_state(|| true);
    let error = use_state(|| None);

    {
        let data = data.clone();
        let loading = loading.clone();
        let error = error.clone();

        use_effect_with((), move |_| {
            let data = data.clone();
            let loading = loading.clone();
            let error = error.clone();

            wasm_bindgen_futures::spawn_local(async move {
                let loader = DataLoader::new();
                match loader.load_articles().await {
                    Ok(articles_data) => {
                        data.set(Some(articles_data));
                        error.set(None);
                    }
                    Err(e) => {
                        error.set(Some(e));
                    }
                }
                loading.set(false);
            });

            || {}
        });
    }

    (data, loading, error)
}

/// Hook for loading lightweight articles (for list display)
#[hook]
pub fn use_lightweight_articles() -> (UseStateHandle<Option<Vec<LightweightArticle>>>, UseStateHandle<bool>, UseStateHandle<Option<DataLoadError>>) {
    let data = use_state(|| None);
    let loading = use_state(|| true);
    let error = use_state(|| None);

    {
        let data = data.clone();
        let loading = loading.clone();
        let error = error.clone();

        use_effect_with((), move |_| {
            let data = data.clone();
            let loading = loading.clone();
            let error = error.clone();

            wasm_bindgen_futures::spawn_local(async move {
                let loader = DataLoader::new();
                match loader.load_lightweight_articles().await {
                    Ok(lightweight_articles) => {
                        data.set(Some(lightweight_articles));
                        error.set(None);
                    }
                    Err(e) => {
                        error.set(Some(e));
                    }
                }
                loading.set(false);
            });

            || {}
        });
    }

    (data, loading, error)
}

/// Hook for loading node registry (for node graph)
#[hook]
pub fn use_node_registry() -> (UseStateHandle<Option<NodeRegistry>>, UseStateHandle<bool>, UseStateHandle<Option<DataLoadError>>) {
    let data = use_state(|| None);
    let loading = use_state(|| true);
    let error = use_state(|| None);

    {
        let data = data.clone();
        let loading = loading.clone();
        let error = error.clone();

        use_effect_with((), move |_| {
            let data = data.clone();
            let loading = loading.clone();
            let error = error.clone();

            wasm_bindgen_futures::spawn_local(async move {
                let loader = DataLoader::new();
                match loader.build_node_registry().await {
                    Ok(node_registry) => {
                        data.set(Some(node_registry));
                        error.set(None);
                    }
                    Err(e) => {
                        error.set(Some(e));
                    }
                }
                loading.set(false);
            });

            || {}
        });
    }

    (data, loading, error)
}

/// Hook for loading a specific article by slug (with caching)
#[hook]
pub fn use_article_content(slug: Option<String>) -> (UseStateHandle<Option<ProcessedArticle>>, UseStateHandle<bool>, UseStateHandle<Option<DataLoadError>>) {
    let data = use_state(|| None);
    let loading = use_state(|| false);
    let error = use_state(|| None);

    {
        let data = data.clone();
        let loading = loading.clone();
        let error = error.clone();

        use_effect_with(slug.clone(), move |slug| {
            if let Some(slug) = slug {
                web_sys::console::log_1(&format!("use_article_content: Loading article with slug: {}", slug).into());

                let data = data.clone();
                let loading = loading.clone();
                let error = error.clone();
                let slug = slug.clone();

                loading.set(true);
                error.set(None);

                wasm_bindgen_futures::spawn_local(async move {
                    let loader = DataLoader::new();
                    match loader.load_article_by_slug(&slug).await {
                        Ok(article) => {
                            web_sys::console::log_1(&format!("use_article_content: Successfully loaded article: {}", article.title).into());
                            data.set(Some(article));
                            error.set(None);
                        }
                        Err(e) => {
                            web_sys::console::log_1(&format!("use_article_content: Failed to load article: {}", e).into());
                            error.set(Some(e));
                        }
                    }
                    loading.set(false);
                });
            } else {
                data.set(None);
                loading.set(false);
                error.set(None);
            }

            || {}
        });
    }

    (data, loading, error)
}